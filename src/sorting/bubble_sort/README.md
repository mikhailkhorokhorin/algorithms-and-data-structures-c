# Bubble Sort

**Пузырьковые сортировки** представляют собой простые методы сортировки, основанные на сравнении и перестановке пар соседних элементов до достижения упорядоченного состояния всего массива. 

## [Классическая пузырьковая сортировка](bubble_sort.c)

Основная идея пузырьковой сортировки заключается в том, что на каждом проходе по массиву соседние элементы сравниваются, и если они находятся в неправильном порядке, то они меняются местами. При этом наименьший (или наибольший, в зависимости от порядка сортировки) элемент "всплывает" на свою позицию, а на каждом следующем проходе оставшаяся неотсортированная часть массива уменьшается на один элемент.

#### Принцип работы:

1. Проходим по массиву несколько раз;
2. На каждом проходе сравниваем пары соседних элементов;
3. Если текущий элемент больше следующего — меняем их местами;
4. После первого прохода наибольший элемент оказывается в конце;
5. После каждого прохода количество элементов, требующих сортировки, уменьшается на один.

#### Сложность:

- **Лучший случай**: **O(n²)** (даже если массив уже отсортирован, алгоритм всё равно проходит по всему массиву);
- **Средний случай**: **O(n²)**;
- **Худший случай**: **O(n²)**;
- **Память**: **O(1)** (in-place);
- **Стабильность**: **Да**.

## [Оптимизированная пузырьковая сортировка](optimized_bubble_sort.c)

Для улучшения пузырьковой сортировки можно применить несколько оптимизаций. Одна из таких оптимизаций заключается в том, чтобы запоминать индекс последнего выполненного обмена. Поскольку все элементы после этого индекса уже упорядочены, проходы по массиву можно сократить до этого индекса, что ускорит сортировку.

Еще одной оптимизацией является чередование направлений проходов по массиву. В классической пузырьковой сортировке элементы "всплывают" с левого конца массива, но можно чередовать направления проходов, что приводит к более быстрой сортировке в некоторых случаях, например, при почти упорядоченных массивах.

#### Принцип работы:

1. В начале каждого прохода устанавливаем флаг `swapped = 0`;
2. Сравниваем и при необходимости меняем элементы местами;
3. Если хотя бы одна перестановка произошла — `swapped = 1`;
4. Если после прохода `swapped` остался равен 0 — выходим из цикла.

#### Сложность:

- **Лучший случай**: **O(n)** - если массив уже отсортирован (проверка `swapped` сразу завершит работу);
- **Средний случай**: **O(n²)**;
- **Худший случай**: **O(n²)**;
- **Память**: **O(1)** (in-place);
- **Стабильность:** **Да**.

## [Шейкерная сортировка](shaker_sort.c)

В отличие от классической пузырьковой сортировки, шейкерная сортировка проходит по массиву в обе стороны. На прямом проходе "всплывает" максимальный элемент в конец, а на обратном — минимальный элемент "тонет" в начало. Это ускоряет процесс, особенно при большом количестве элементов, стоящих не на своих местах в начале массива.

#### Принцип работы:

1. Устанавливаются границы `left` и `right`;
2. Проходим массив слева направо: сравниваем соседние элементы и при необходимости меняем их местами;
3. После прохода уменьшаем `right`, так как последний элемент уже на месте;
4. Затем проходим справа налево, выполняя аналогичные операции;
5. После прохода увеличиваем `left`;
6. Повторяем, пока не будет сделано ни одной перестановки (`swapped = 0`).
    
#### Сложность:

- **Лучший случай**: **O(n)** - если массив уже отсортирован;
- **Средний случай**: **O(n²)**;
- **Худший случай**: **O(n²)**;
- **Память**: **O(1)** (in-place);
- **Стабильность**: **Да**.